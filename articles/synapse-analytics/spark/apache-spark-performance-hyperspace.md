---
title: Hyperspace-Indizes für Apache Spark
description: Leistungsoptimierung für Apache Spark unter Verwendung von Hyperspace-Indizes
services: synapse-analytics
author: euangMS
ms.service: synapse-analytics
ms.topic: conceptual
ms.subservice: spark
ms.date: 08/12/2020
ms.author: euang
ms.reviewer: euang
zone_pivot_groups: programming-languages-spark-all-minus-sql
ms.openlocfilehash: 3d65a7771ff2bd8807a5f02278b0455ee103dbd6
ms.sourcegitcommit: 03662d76a816e98cfc85462cbe9705f6890ed638
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 09/15/2020
ms.locfileid: "90526339"
---
# <a name="hyperspace---an-indexing-subsystem-for-apache-spark"></a>Hyperspace: Ein Indizierungsuntersystem für Apache Spark

Hyperspace bietet Apache Spark-Benutzern die Möglichkeit, Indizes für ihre Datasets (z. B. CSV, JSON, Parquet usw.) zu erstellen und diese zur potenziellen Beschleunigung von Abfragen und Workloads zu nutzen.

In diesem Artikel werden die Grundlagen von Hyperspace vorgestellt, wobei seine Einfachheit hervorgehoben und gezeigt wird, wie es von nahezu jedermann verwendet werden kann.

Haftungsausschluss: Hyperspace unterstützt Sie unter zwei Umständen beim Beschleunigen Ihrer Workloads/Abfragen:

* Abfragen enthalten Filter für Prädikate mit hoher Selektivität (wenn Sie z. B. 100 übereinstimmende Zeilen aus einer Million Kandidatenzeilen auswählen möchten)
* Abfragen enthalten einen Join, der starke Shufflevorgänge erfordert (wenn Sie z. B. ein 100 GB-Dataset mit einem 10 GB-Dataset verknüpfen möchten)

Vielleicht sollten Ihre Workloads sorgfältig überwachen und von Fall zu Fall bestimmen, ob die Indizierung für Sie hilfreich ist.

Dieses Dokument liegt für [Python](https://github.com/microsoft/hyperspace/blob/master/notebooks/python/Hitchhikers%20Guide%20to%20Hyperspace.ipynb), [C#](https://github.com/microsoft/hyperspace/blob/master/notebooks/csharp/Hitchhikers%20Guide%20to%20Hyperspace.ipynb) und [Scala](https://github.com/microsoft/hyperspace/blob/master/notebooks/scala/Hitchhikers%20Guide%20to%20Hyperspace.ipynb) auch in Notebookform vor.

## <a name="setup"></a>Setup

Beginnen Sie mit einer neuen Spark-Sitzung. Da es sich bei diesem Dokument um ein Tutorial handelt, das lediglich veranschaulichen soll, was Hyperspace bieten kann, werden Sie eine Konfigurationsänderung vornehmen, die es uns erlaubt, hervorzuheben, wie Hyperspace bei kleinen Datasets vorgeht. Standardmäßig verwendet Spark Broadcastjoins zur Optimierung von Joinabfragen, wenn die Datengröße für eine Joinseite klein ist (was bei den Beispieldaten, die wir in diesem Tutorial verwenden, der Fall ist). Daher deaktivieren wir Broadcastjoins, sodass Spark später beim Ausführen von Joinabfragen entsprechende Sort-Merge-Joins verwendet. Dies dient vor allem dazu zu zeigen, wie Hyperspace-Indizes im großen Stil zur Beschleunigung von Joinabfragen verwendet würden.

Die Ausgabe der Ausführung der nachfolgenden Zelle zeigt einen Verweis auf die erfolgreich erstellte Spark-Sitzung und gibt „-1“ als Wert für die geänderte Joinkonfiguration aus, was anzeigt, dass der Broadcastjoin erfolgreich deaktiviert wurde.

:::zone pivot = "programming-language-scala"

```scala
// Start your Spark session
spark

// Disable BroadcastHashJoin, so Spark will use standard SortMergeJoin. Currently hyperspace indexes utilize SortMergeJoin to speed up query.
spark.conf.set("spark.sql.autoBroadcastJoinThreshold", -1)

// Verify that BroadcastHashJoin is set correctly
println(spark.conf.get("spark.sql.autoBroadcastJoinThreshold"))

```

::: zone-end

:::zone pivot = "programming-language-python"

```python
# Start your Spark session
spark

# Disable BroadcastHashJoin, so Spark will use standard SortMergeJoin. Currently Hyperspace indexes utilize SortMergeJoin to speed up query.
spark.conf.set("spark.sql.autoBroadcastJoinThreshold", -1)

# Verify that BroadcastHashJoin is set correctly 
print(spark.conf.get("spark.sql.autoBroadcastJoinThreshold"))
```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp
// Disable BroadcastHashJoin, so Spark™ will use standard SortMergeJoin. Currently hyperspace indexes utilize SortMergeJoin to speed up query.
spark.Conf().Set("spark.sql.autoBroadcastJoinThreshold", -1);

// Verify that BroadcastHashJoin is set correctly 
Console.WriteLine(spark.Conf().Get("spark.sql.autoBroadcastJoinThreshold"));
```

::: zone-end

Ergebnis:

```console
res3: org.apache.spark.sql.SparkSession = org.apache.spark.sql.SparkSession@297e957d
-1
```

## <a name="data-preparation"></a>Vorbereitung der Daten

Zur Vorbereitung Ihrer Umgebung erstellen Sie Beispieldatensätze, die Sie als Parquet-Datendateien speichern. Obwohl Parquet zur Veranschaulichung verwendet wird, können Sie auch andere Formate wie CSV verwenden. In den folgenden Zellen sehen Sie, wie Sie mehrere Hyperspace-Indizes für dieses Beispieldataset erstellen und Spark dazu bringen können, diese bei der Ausführung von Abfragen zu verwenden.

Die Beispieldatensätze entsprechen zwei Datasets: Abteilung und Mitarbeiter. Sie sollten die Pfade „empLocation“ und „deptLocation“ so konfigurieren, dass sie für das Speicherkonto auf den gewünschten Speicherort zum Speichern der generierten Datendateien verweisen.

Die Ausgabe der Ausführung der nachfolgenden Zelle zeigt den Inhalt unserer Datasets als Listen von Dreiergruppen an, gefolgt von Verweisen auf Datenrahmen, die erstellt wurden, um den Inhalt der einzelnen Datasets an unserem bevorzugten Speicherort zu speichern.

:::zone pivot = "programming-language-scala"

```scala
import org.apache.spark.sql.DataFrame

// Sample department records
val departments = Seq(
      (10, "Accounting", "New York"),
      (20, "Research", "Dallas"),
      (30, "Sales", "Chicago"),
      (40, "Operations", "Boston"))

// Sample employee records
val employees = Seq(
      (7369, "SMITH", 20),
      (7499, "ALLEN", 30),
      (7521, "WARD", 30),
      (7566, "JONES", 20),
      (7698, "BLAKE", 30),
      (7782, "CLARK", 10),
      (7788, "SCOTT", 20),
      (7839, "KING", 10),
      (7844, "TURNER", 30),
      (7876, "ADAMS", 20),
      (7900, "JAMES", 30),
      (7934, "MILLER", 10),
      (7902, "FORD", 20),
      (7654, "MARTIN", 30))

// Save sample data in the Parquet format
import spark.implicits._
val empData: DataFrame = employees.toDF("empId", "empName", "deptId")
val deptData: DataFrame = departments.toDF("deptId", "deptName", "location")

val empLocation: String = "/<yourpath>/employees.parquet"       //TODO ** customize this location path **
val deptLocation: String = "/<yourpath>/departments.parquet"     //TODO ** customize this location path **
empData.write.mode("overwrite").parquet(empLocation)
deptData.write.mode("overwrite").parquet(deptLocation)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

from pyspark.sql.types import StructField, StructType, StringType, IntegerType

# Sample department records
departments = [(10, "Accounting", "New York"), (20, "Research", "Dallas"), (30, "Sales", "Chicago"), (40, "Operations", "Boston")]

# Sample employee records
employees = [(7369, "SMITH", 20), (7499, "ALLEN", 30), (7521, "WARD", 30), (7566, "JONES", 20), (7698, "BLAKE", 30)]

# Create a schema for the dataframe
dept_schema = StructType([StructField('deptId', IntegerType(), True), StructField('deptName', StringType(), True), StructField('location', StringType(), True)])
emp_schema = StructType([StructField('empId', IntegerType(), True), StructField('empName', StringType(), True), StructField('deptId', IntegerType(), True)])

departments_df = spark.createDataFrame(departments, dept_schema)
employees_df = spark.createDataFrame(employees, emp_schema)

#TODO ** customize this location path **
emp_Location = "/<yourpath>/employees.parquet"
dept_Location = "/<yourpath>/departments.parquet"

employees_df.write.mode("overwrite").parquet(emp_Location)
departments_df.write.mode("overwrite").parquet(dept_Location)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

using Microsoft.Spark.Sql.Types;

// Sample department records
var departments = new List<GenericRow>()
{
    new GenericRow(new object[] {10, "Accounting", "New York"}),
    new GenericRow(new object[] {20, "Research", "Dallas"}),
    new GenericRow(new object[] {30, "Sales", "Chicago"}),
    new GenericRow(new object[] {40, "Operations", "Boston"})
};

// Sample employee records
var employees = new List<GenericRow>() {
      new GenericRow(new object[] {7369, "SMITH", 20}),
      new GenericRow(new object[] {7499, "ALLEN", 30}),
      new GenericRow(new object[] {7521, "WARD", 30}),
      new GenericRow(new object[] {7566, "JONES", 20}),
      new GenericRow(new object[] {7698, "BLAKE", 30}),
      new GenericRow(new object[] {7782, "CLARK", 10}),
      new GenericRow(new object[] {7788, "SCOTT", 20}),
      new GenericRow(new object[] {7839, "KING", 10}),
      new GenericRow(new object[] {7844, "TURNER", 30}),
      new GenericRow(new object[] {7876, "ADAMS", 20}),
      new GenericRow(new object[] {7900, "JAMES", 30}),
      new GenericRow(new object[] {7934, "MILLER", 10}),
      new GenericRow(new object[] {7902, "FORD", 20}),
      new GenericRow(new object[] {7654, "MARTIN", 30})
};

// Save sample data in the Parquet format
var departmentSchema = new StructType(new List<StructField>()
{
    new StructField("deptId", new IntegerType()),
    new StructField("deptName", new StringType()),
    new StructField("location", new StringType())
});
var employeeSchema = new StructType(new List<StructField>()
{
    new StructField("empId", new IntegerType()),
    new StructField("empName", new StringType()),
    new StructField("deptId", new IntegerType())
});

DataFrame empData = spark.CreateDataFrame(employees, employeeSchema); 
DataFrame deptData = spark.CreateDataFrame(departments, departmentSchema); 

string empLocation = "/<yourpath>/employees.parquet";       //TODO ** customize this location path **
string deptLocation = "/<yourpath>/departments.parquet";     //TODO ** customize this location path **
empData.Write().Mode("overwrite").Parquet(empLocation);
deptData.Write().Mode("overwrite").Parquet(deptLocation);

```

::: zone-end

Ergebnis:

```console
import org.apache.spark.sql.DataFrame  
departments: Seq[(Int, String, String)] = List((10,Accounting,New York), (20,Research,Dallas), (30,Sales,Chicago), (40,Operations,Boston))  
employees: Seq[(Int, String, Int)] = List((7369,SMITH,20), (7499,ALLEN,30), (7521,WARD,30), (7566,JONES,20), (7698,BLAKE,30), (7782,CLARK,10), (7788,SCOTT,20), (7839,KING,10), (7844,TURNER,30), (7876,ADAMS,20), (7900,JAMES,30), (7934,MILLER,10), (7902,FORD,20), (7654,MARTIN,30))  
import spark.implicits._  
empData: org.apache.spark.sql.DataFrame = [empId: int, empName: string ... 1 more field]  
deptData: org.apache.spark.sql.DataFrame = [deptId: int, deptName: string ... 1 more field]  
empLocation: String = /your-path/employees.parquet  
deptLocation: String = /your-path/departments.parquet  
```

Lassen Sie uns den Inhalt der oben erstellten Parquet-Dateien überprüfen, um sicherzustellen, dass sie die erwarteten Datensätze im richtigen Format enthalten. Wir verwenden diese Datendateien später zum Erstellen von Hyperspace-Indizes und zum Ausführen von Beispielabfragen.

Beim Ausführen der folgenden Zelle zeigt die Ausgabe die Zeilen in Datenrahmen für Mitarbeiter und Abteilung in tabellarischer Form an. Es sollte 14 Mitarbeiter und 4 Abteilungen geben, die jeweils mit einer der Dreiergruppen übereinstimmen, die Sie in der vorherigen Zelle erstellt haben.

:::zone pivot = "programming-language-scala"

```scala
// empLocation and deptLocation are the user defined locations above to save parquet files
val empDF: DataFrame = spark.read.parquet(empLocation)
val deptDF: DataFrame = spark.read.parquet(deptLocation)

// Verify the data is available and correct
empDF.show()
deptDF.show()
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# emp_Location and dept_Location are the user defined locations above to save parquet files
emp_DF = spark.read.parquet(emp_Location)
dept_DF = spark.read.parquet(dept_Location)

# Verify the data is available and correct
emp_DF.show()
dept_DF.show()

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// empLocation and deptLocation are the user defined locations above to save parquet files
DataFrame empDF = spark.Read().Parquet(empLocation);
DataFrame deptDF = spark.Read().Parquet(deptLocation);

// Verify the data is available and correct
empDF.Show();
deptDF.Show();

```

::: zone-end

Ergebnis:

```console
empDF: org.apache.spark.sql.DataFrame = [empId: int, empName: string ... 1 more field]  
deptDF: org.apache.spark.sql.DataFrame = [deptId: int, deptName: string ... 1 more field]
```

```console
|EmpId|EmpName|DeptId|
|-----|-------|------|
| 7499|  ALLEN|    30|
| 7521|   WARD|    30|
| 7369|  SMITH|    20|
| 7844| TURNER|    30|
| 7876|  ADAMS|    20|
| 7900|  JAMES|    30|
| 7934| MILLER|    10|
| 7839|   KING|    10|
| 7566|  JONES|    20|
| 7698|  BLAKE|    30|
| 7782|  CLARK|    10|
| 7788|  SCOTT|    20|
| 7902|   FORD|    20|
| 7654| MARTIN|    30|  
```

&nbsp; &nbsp;

```console
|DeptId|  DeptName|Location|
|------|----------|--------|
|    10|Accounting|New York|
|    40|Operations|  Boston|
|    20|  Research|  Dallas|
|    30|     Sales| Chicago|
```

## <a name="indexes"></a>Indizes

Mit Hyperspace können Sie Indizes für Datensätze erstellen, die aus persistierten Datendateien gescannt wurden. Nach erfolgreicher Erstellung wird ein Eintrag, der dem Index entspricht, zu den Hyperspace-Metadaten hinzugefügt. Diese Metadaten werden später vom Optimierer von Apache Spark (mit unseren Erweiterungen) während der Abfrageverarbeitung verwendet, um die richtigen Indizes zu finden und zu verwenden.

Nachdem Indizes erstellt wurden, können Sie verschiedene Aktionen durchführen:

Aktualisieren – Wenn sich die zugrunde liegenden Daten ändern, können Sie einen vorhandenen Index aktualisieren, um dies zu erfassen.
Löschen – Wenn der Index nicht benötigt wird, können Sie einen vorläufigen Löschvorgang durchführen, d. h. der Index wird nicht physisch gelöscht, sondern als „gelöscht“ markiert, sodass er nicht mehr in Ihren Workloads verwendet wird.
Bereinigen – Wenn ein Index nicht mehr benötigt wird, können Sie ihn bereinigen, was eine vollständige physische Löschung des Indexinhalts und der zugehörigen Metadaten aus den Metadaten von Hyperspace erzwingt.
Die folgenden Abschnitte zeigen, wie solche Vorgänge zur Indexverwaltung in Hyperspace durchgeführt werden können.

Zuerst müssen Sie die erforderlichen Bibliotheken importieren und eine Instanz von Hyperspace erstellen. Sie werden diese Instanz später zum Aufrufen verschiedener Hyperspace-APIs verwenden, um Indizes für Ihre Beispieldaten zu erstellen und diese Indizes zu ändern.

Die Ausgabe der Ausführung der folgenden Zelle zeigt einen Verweis auf die erstellte Instanz von Hyperspace.

:::zone pivot = "programming-language-scala"

```scala
// Create an instance of Hyperspace
import com.microsoft.hyperspace._

val hyperspace: Hyperspace = Hyperspace()
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Create an instance of Hyperspace
hyperspace = Hyperspace(spark)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Create an instance of Hyperspace
using Microsoft.Spark.Extensions.Hyperspace;

Hyperspace hyperspace = new Hyperspace(spark);

```

::: zone-end

Ergebnis:

```console
import com.microsoft.hyperspace._  
hyperspace: com.microsoft.hyperspace.Hyperspace = com.microsoft.hyperspace.Hyperspace@1432f740
```

## <a name="create-indexes"></a>Erstellen von Indizes

Sie müssen zwei Informationen angeben, um einen Hyperspace-Index zu erstellen:

Einen Spark-Datenrahmen, der auf die zu indexierenden Daten verweist.
Ein Indexkonfigurationsobjekt: IndexConfig, das den Indexnamen sowie die indizierten und eingeschlossenen Spalten des Index angibt.
Sie beginnen damit, drei Hyperspace-Indizes für unsere Beispieldaten zu erstellen. Zwei Indizes für das Dataset „Abteilung“ namens „deptIndex1“ und „deptIndex2“ und einen Index für das Dataset „Mitarbeiter“ namens „empIndex“. Für jeden Index benötigen Sie eine entsprechende Indexkonfiguration (IndexConfig), um den Namen zusammen mit den Spaltenlisten für die indizierten und eingeschlossenen Spalten zu erfassen. Durch Ausführen der folgenden Zelle werden diese Indexkonfigurationen erstellt und in der Ausgabe aufgelistet.

> [!Note]
> Eine Indexspalte ist eine Spalte, die in Ihren Filtern oder Joinbedingungen angezeigt wird. Eine eingeschlossene Spalte ist eine Spalte, die in Ihrer Auswahl bzw. Ihrem Projekt aufgeführt wird.

Folgendes gilt z. B. für die nachfolgende Abfrage:

```sql
SELECT X
FROM T
WHERE Y = 2
```

X kann eine Indexspalte und Y eine eingeschlossene Spalte sein.

:::zone pivot = "programming-language-scala"

```scala
// Create index configurations
import com.microsoft.hyperspace.index.IndexConfig

val empIndexConfig: IndexConfig = IndexConfig("empIndex", Seq("deptId"), Seq("empName"))
val deptIndexConfig1: IndexConfig = IndexConfig("deptIndex1", Seq("deptId"), Seq("deptName"))
val deptIndexConfig2: IndexConfig = IndexConfig("deptIndex2", Seq("location"), Seq("deptName"))
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Create index configurations

emp_IndexConfig = IndexConfig("empIndex1", ["deptId"], ["empName"])
dept_IndexConfig1 = IndexConfig("deptIndex1", ["deptId"], ["deptName"])
dept_IndexConfig2 = IndexConfig("deptIndex2", ["location"], ["deptName"])

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

using Microsoft.Spark.Extensions.Hyperspace.Index;

var empIndexConfig = new IndexConfig("empIndex", new string[] {"deptId"}, new string[] {"empName"});
var deptIndexConfig1 = new IndexConfig("deptIndex1", new string[] {"deptId"}, new string[] {"deptName"});
var deptIndexConfig2 = new IndexConfig("deptIndex2", new string[] {"location"}, new string[] {"deptName"});

```

::: zone-end

Ergebnis:

```console
import com.microsoft.hyperspace.index.IndexConfig  
empIndexConfig: com.microsoft.hyperspace.index.IndexConfig = [indexName: empIndex; indexedColumns: deptid; includedColumns: empname]  
deptIndexConfig1: com.microsoft.hyperspace.index.IndexConfig = [indexName: deptIndex1; indexedColumns: deptid; includedColumns: deptname]  
deptIndexConfig2: com.microsoft.hyperspace.index.IndexConfig = [indexName: deptIndex2; indexedColumns: location; includedColumns: deptname]  
```

Jetzt erstellen Sie drei Indizes mithilfe Ihrer Indexkonfigurationen. Zu diesem Zweck rufen Sie den Befehl „createIndex“ für unsere Hyperspace-Instanz auf. Dieser Befehl erfordert eine Indexkonfiguration und den Datenrahmen, der die zu indizierenden Zeilen enthält. Die Ausführung der folgenden Zelle erstellt drei Indizes.

:::zone pivot = "programming-language-scala"

```scala
// Create indexes from configurations
import com.microsoft.hyperspace.index.Index

hyperspace.createIndex(empDF, empIndexConfig)
hyperspace.createIndex(deptDF, deptIndexConfig1)
hyperspace.createIndex(deptDF, deptIndexConfig2)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Create indexes from configurations

hyperspace.createIndex(emp_DF, emp_IndexConfig)
hyperspace.createIndex(dept_DF, dept_IndexConfig1)
hyperspace.createIndex(dept_DF, dept_IndexConfig2)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Create indexes from configurations
hyperspace.CreateIndex(empDF, empIndexConfig);
hyperspace.CreateIndex(deptDF, deptIndexConfig1);
hyperspace.CreateIndex(deptDF, deptIndexConfig2);

```

::: zone-end

Ergebnis:

```console
import com.microsoft.hyperspace.index.Index
```

## <a name="list-indexes"></a>Indizes auflisten

Der folgende Code zeigt, wie Sie alle verfügbaren Indizes in einer Hyperspace-Instanz auflisten können. Er verwendet die API „Indizes“, die Informationen über vorhandene Indizes als Spark-Datenrahmen zurückgibt, sodass Sie zusätzliche Vorgänge ausführen können. Sie können z. B. gültige Vorgänge für diesen Datenrahmen aufrufen, um seinen Inhalt zu prüfen oder ihn weiter zu analysieren (z. B. bestimmte Indizes filtern oder sie nach einer gewünschten Eigenschaft gruppieren).

Die folgende Zelle verwendet die „show“-Aktion des Datenrahmens, um die Zeilen vollständig auszugeben und Details unserer Indizes in tabellarischer Form anzuzeigen. Für jeden Index können Sie alle Informationen anzeigen, die Hyperspace über ihn in den Metadaten gespeichert hat. Sie werden sofort Folgendes bemerken:

* „config.indexName“, „config.indexedColumns“, „config.includedColumns“ und „status.status“ sind die Felder, auf die sich ein Benutzer normalerweise bezieht.
* „dfSignature“ wird automatisch vom Hyperspace generiert und ist für jeden Index eindeutig. Hyperspace verwendet diese Signatur intern, um den Index zu verwalten und zur Abfragezeit zu verwerten.

In der folgenden Ausgabe sollten alle drei Indizes den Status „AKTIV“ aufweisen, und ihr Name, die indizierten Spalten und die eingeschlossenen Spalten sollten mit dem übereinstimmen, was wir oben in den Indexkonfigurationen definiert haben.

:::zone pivot = "programming-language-scala"

```scala
hyperspace.indexes.show
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

hyperspace.indexes().show()

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

hyperspace.Indexes().Show();

```

::: zone-end

Ergebnis:

```console
|Config.IndexName|Config.IndexedColumns|Config.IncludedColumns|        SchemaString|   SignatureProvider|         DfSignature|      SerializedPlan|NumBuckets|             DirPath|Status.Value|Stats.IndexSize|
|----------------|---------------------|----------------------|--------------------|--------------------|--------------------|--------------------|----------|--------------------|------------|---------------|
|      deptIndex1|             [deptId]|            [deptName]|`deptId` INT,`dep...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|      ACTIVE|              0|
|      deptIndex2|           [location]|            [deptName]|`location` STRING...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|      ACTIVE|              0|
|        empIndex|             [deptId]|             [empName]|`deptId` INT,`emp...|com.microsoft.cha...|30768c6c9b2533004...|Relation[empId#32...|       200|abfss://datasets@...|      ACTIVE|              0|
```

## <a name="delete-indexes"></a>Indizes löschen

Sie können einen bestehenden Index löschen, indem Sie die API „deleteIndex“ verwenden und den Indexnamen angeben. Beim Löschen des Index wird ein vorläufiger Löschvorgang durchgeführt: Es wird hauptsächlich der Status des Index in den Hyperspace-Metadaten von „AKTIV“ auf „GELÖSCHT“ aktualisiert. Dadurch wird der gelöschte Index von jeder zukünftigen Abfrageoptimierung ausgeschlossen und Hyperspace wählt diesen Index nicht mehr für eine Abfrage aus. Indexdateien für einen gelöschten Index bleiben jedoch weiterhin verfügbar (da es sich um ein vorläufiges Löschen handelt), sodass der Index auf Wunsch des Benutzers wiederhergestellt werden kann.

Die folgende Zelle löscht den Index namens „deptIndex2“ und listet danach Hyperspace-Metadaten auf. Die Ausgabe sollte der obigen Zelle für „Indizes auflisten“ ähnlich sein, mit Ausnahme von „deptIndex2“, dessen Status jetzt in „GELÖSCHT“ geändert werden sollte.

:::zone pivot = "programming-language-scala"

```scala
hyperspace.deleteIndex("deptIndex2")

hyperspace.indexes.show
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

hyperspace.deleteIndex("deptIndex2")
hyperspace.indexes().show()

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp
hyperspace.DeleteIndex("deptIndex2");

hyperspace.Indexes().Show();

```

::: zone-end

Ergebnis:

```console
|Config.IndexName|Config.IndexedColumns|Config.IncludedColumns|        SchemaString|   SignatureProvider|         DfSignature|      SerializedPlan|NumBuckets|             DirPath|Status.Value|Stats.IndexSize|
|----------------|---------------------|----------------------|--------------------|--------------------|--------------------|--------------------|----------|--------------------|------------|---------------|
|      deptIndex1|             [deptId]|            [deptName]|`deptId` INT,`dep...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|      ACTIVE|              0|
|      deptIndex2|           [location]|            [deptName]|`location` STRING...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|     DELETED|              0|
|        empIndex|             [deptId]|             [empName]|`deptId` INT,`emp...|com.microsoft.cha...|30768c6c9b2533004...|Relation[empId#32...|       200|abfss://datasets@...|      ACTIVE|              0|
```

## <a name="restore-indexes"></a>Indizes wiederherstellen

Sie können die API „restoreIndex“ verwenden, um einen gelöschten Index wiederherzustellen. Dadurch wird die neueste Version des Index wieder in den Status „AKTIV“ versetzt und für Abfragen erneut verfügbar gemacht. Die folgende Zelle zeigt ein Beispiel für die Verwendung von „restoreIndex“. Sie löschen „deptIndex1“ und stellen ihn wieder her. Die Ausgabe zeigt, dass „deptIndex1“ nach dem Aufruf des Befehls „deleteIndex“ zunächst zum Status „GELÖSCHT“ wechselte und nach dem Aufruf von „restoreIndex“ zum Status „AKTIV“ zurückkehrte.

:::zone pivot = "programming-language-scala"

```scala
hyperspace.deleteIndex("deptIndex1")

hyperspace.indexes.show

hyperspace.restoreIndex("deptIndex1")

hyperspace.indexes.show
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

hyperspace.deleteIndex("deptIndex1")
hyperspace.indexes().show()
hyperspace.restoreIndex("deptIndex1")
hyperspace.indexes().show()

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

hyperspace.DeleteIndex("deptIndex1");
hyperspace.Indexes().Show();
hyperspace.RestoreIndex("deptIndex1");
hyperspace.Indexes().Show();

```

::: zone-end

Ergebnis:

```console
|Config.IndexName|Config.IndexedColumns|Config.IncludedColumns|        SchemaString|   SignatureProvider|         DfSignature|      SerializedPlan|NumBuckets|             DirPath|Status.Value|Stats.indexSize|
|----------------|---------------------|----------------------|--------------------|--------------------|--------------------|--------------------|----------|--------------------|------------|---------------|
|      deptIndex1|             [deptId]|            [deptName]|`deptId` INT,`dep...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|     DELETED|              0|
|      deptIndex2|           [location]|            [deptName]|`location` STRING...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|     DELETED|              0|
|        empIndex|             [deptId]|             [empName]|`deptId` INT,`emp...|com.microsoft.cha...|30768c6c9b2533004...|Relation[empId#32...|       200|abfss://datasets@...|      ACTIVE|              0|
```

&nbsp; &nbsp;

```console
|Config.IndexName|Config.IndexedColumns|Config.IncludedColumns|        SchemaString|   SignatureProvider|         DfSignature|      SerializedPlan|NumBuckets|             DirPath|Status.value|Stats.IndexSize|
|----------------|---------------------|----------------------|--------------------|--------------------|--------------------|--------------------|----------|--------------------|------------|---------------|
|      deptIndex1|             [deptId]|            [deptName]|`deptId` INT,`dep...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|      ACTIVE|              0|
|      deptIndex2|           [location]|            [deptName]|`location` STRING...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|     DELETED|              0|
|        empIndex|             [deptId]|             [empName]|`deptId` INT,`emp...|com.microsoft.cha...|30768c6c9b2533004...|Relation[empId#32...|       200|abfss://datasets@...|      ACTIVE|              0|
```

## <a name="vacuum-indexes"></a>Indizes bereinigen

Sie können einen endgültigen Löschvorgang durchführen, d. h. Dateien und den Metadateneintrag für einen gelöschten Index mithilfe des Befehls „vacuumIndex“ vollständig entfernen. Einmal durchgeführt, kann diese Aktion nicht rückgängig gemacht werden, da sie alle Indexdateien physisch löscht (weshalb es sich um einen endgültigen Löschvorgang handelt).

Die folgende Zelle bereinigt den Index „deptIndex2“ und zeigt nach dem Bereinigen Hyperspace-Metadaten an. Sie sollten Metadateneinträge für die beiden Indizes „deptIndex1“ und „empIndex“ sehen, beide mit dem Status „AKTIV“, und keinen Eintrag für „deptIndex2“.

:::zone pivot = "programming-language-scala"

```scala
hyperspace.vacuumIndex("deptIndex2")

hyperspace.indexes.show
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

hyperspace.vacuumIndex("deptIndex2")
hyperspace.indexes().show()

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

hyperspace.VacuumIndex("deptIndex2");
hyperspace.Indexes().Show();

```

::: zone-end

Ergebnis:

```console
|Config.IndexName|Config.IndexedColumns|Config.IncludedColumns|        SchemaString|   SignatureProvider|         DfSignature|      SerializedPlan|NumBuckets|             DirPath|Status.Value|Stats.IndexSize|
|----------------|---------------------|----------------------|--------------------|--------------------|--------------------|--------------------|----------|--------------------|------------|---------------|
|      deptIndex1|             [deptId]|            [deptName]|`deptId` INT,`dep...|com.microsoft.cha...|0effc1610ae2e7c49...|Relation[deptId#3...|       200|abfss://datasets@...|      ACTIVE|              0|
|        empIndex|             [deptId]|             [empName]|`deptId` INT,`emp...|com.microsoft.cha...|30768c6c9b2533004...|Relation[empId#32...|       200|abfss://datasets@...|      ACTIVE|              0|
```

## <a name="enabledisable-hyperspace"></a>Hyperspace aktivieren/deaktivieren

Hyperspace bietet APIs zum Aktivieren oder Deaktivieren der Indexnutzung mit Spark.

Mithilfe des Befehls „enableHyperspace“ werden die Hyperspace-Optimierungsregeln für den Spark-Optimierer sichtbar, und sie verwerten vorhandene Hyperspace-Indizes zur Optimierung der Benutzerabfragen.
Durch die Verwendung des Befehls „disableHyperspace“ gelten die Hyperspace-Regeln während der Abfrageoptimierung nicht mehr. Sie sollten beachten, dass die Deaktivierung von Hyperspace keine Auswirkungen auf erstellte Indizes hat, da diese unverändert bleiben.
Die folgende Zelle zeigt, wie Sie Hyperspace mithilfe dieser Befehle aktivieren oder deaktivieren können. Die Ausgabe zeigt lediglich einen Verweis auf die vorhandene Spark-Sitzung, deren Konfiguration aktualisiert wird.

:::zone pivot = "programming-language-scala"

```scala
// Enable Hyperspace
spark.enableHyperspace

// Disable Hyperspace
spark.disableHyperspace
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Enable Hyperspace
Hyperspace.enable(spark)

# Disable Hyperspace
Hyperspace.disable(spark)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Enable Hyperspace
spark.EnableHyperspace();

// Disable Hyperspace
spark.DisableHyperspace();

```

::: zone-end

Ergebnis:

```console
res48: org.apache.spark.sql.Spark™Session = org.apache.spark.sql.SparkSession@39fe1ddb  
res51: org.apache.spark.sql.Spark™Session = org.apache.spark.sql.SparkSession@39fe1ddb
```

## <a name="index-usage"></a>Indexnutzung

Damit Spark während der Abfrageverarbeitung Hyperspace-Indizes verwenden kann, müssen Sie sicherstellen, dass Hyperspace aktiviert ist.

Die folgende Zelle aktiviert Hyperspace und erstellt zwei Datenrahmen mit Ihren Beispieldatensätzen, die Sie zum Ausführen von Beispielabfragen verwenden können. Für jeden Datenrahmen werden einige Beispielzeilen ausgegeben.

:::zone pivot = "programming-language-scala"

```scala
// Enable Hyperspace
spark.enableHyperspace

val empDFrame: DataFrame = spark.read.parquet(empLocation)
val deptDFrame: DataFrame = spark.read.parquet(deptLocation)

empDFrame.show(5)
deptDFrame.show(5)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Enable Hyperspace
Hyperspace.enable(spark)

emp_DF = spark.read.parquet(emp_Location)
dept_DF = spark.read.parquet(dept_Location)

emp_DF.show(5)
dept_DF.show(5)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Enable Hyperspace
spark.EnableHyperspace();

DataFrame empDFrame = spark.Read().Parquet(empLocation);
DataFrame deptDFrame = spark.Read().Parquet(deptLocation);

empDFrame.Show(5);
deptDFrame.Show(5);

```

::: zone-end

Ergebnis:

```console
res53: org.apache.spark.sql.Spark™Session = org.apache.spark.sql.Spark™Session@39fe1ddb  
empDFrame: org.apache.spark.sql.DataFrame = [empId: int, empName: string ... 1 more field]  
deptDFrame: org.apache.spark.sql.DataFrame = [deptId: int, deptName: string ... 1 more field]  
```

&nbsp; &nbsp;

```console
|empId|empName|deptId|
|-----|-------|------|
| 7499|  ALLEN|    30|
| 7521|   WARD|    30|
| 7369|  SMITH|    20|
| 7844| TURNER|    30|
| 7876|  ADAMS|    20|
```

&nbsp; &nbsp; Hier werden nur die oberen 5 Zeilen angezeigt &nbsp; &nbsp;

```console
|deptId|  deptName|location|
|------|----------|--------|
|    10|Accounting|New York|
|    40|Operations|  Boston|
|    20|  Research|  Dallas|
|    30|     Sales| Chicago|
```

## <a name="index-types"></a>Indextypen

Gegenwärtig verfügt Hyperspace über Regeln zur Nutzung von Indizes für zwei Gruppen von Abfragen:

* Auswahlabfragen mit Filterprädikaten für Lookup oder Bereichsauswahl.
* Verknüpfen Sie Abfragen mit einem Gleichheits-Join-Prädikat (d. h. „Equi-joins“).

## <a name="indexes-for-accelerating-filters"></a>Indizes zur Beschleunigung von Filtern

Die erste Beispielabfrage führt einen Lookup für Datensätze vom Typ „Abteilung“ durch (siehe folgende Zelle). In SQL sieht diese Abfrage wie folgt aus:

```sql
SELECT deptName
FROM departments
WHERE deptId = 20
```

Das Ergebnis der Ausführung der folgenden Zelle zeigt:

* Abfrageergebnis, bei dem es sich um einen einzelnen Abteilungsnamen handelt.
* Abfrageplan, den Spark zur Ausführung der Abfrage verwendet hat.

Im Abfrageplan zeigt der „FileScan“-Operator am unteren Rand des Plans die Datenquelle an, aus der die Datensätze gelesen wurden. Der Speicherort dieser Datei gibt den Pfad zur neuesten Version des Index „deptIndex1“ an. Dies zeigt, dass Spark gemäß der Abfrage und mithilfe der Hyperspace-Optimierungsregeln beschlossen hat, den richtigen Index zur Runtime zu verwerten.

:::zone pivot = "programming-language-scala"

```scala
// Filter with equality predicate

val eqFilter: DataFrame = deptDFrame.filter("deptId = 20").select("deptName")
eqFilter.show()

eqFilter.explain(true)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Filter with equality predicate

eqFilter = dept_DF.filter("""deptId = 20""").select("""deptName""")
eqFilter.show()

eqFilter.explain(True)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

DataFrame eqFilter = deptDFrame.Filter("deptId = 20").Select("deptName");
eqFilter.Show();

eqFilter.Explain(true);

```

::: zone-end

Ergebnis:

```console
eqFilter: org.apache.spark.sql.DataFrame = [deptName: string]
```

```console
|DeptName|
|--------|
|Research|
```

&nbsp; &nbsp;

```console
== Parsed Logical Plan ==
'Project [unresolvedalias('deptName, None)]
+- Filter (deptId#533 = 20)
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Analyzed Logical Plan ==
deptName: string
Project [deptName#534]
+- Filter (deptId#533 = 20)
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Optimized Logical Plan ==
Project [deptName#534]
+- Filter (isnotnull(deptId#533) && (deptId#533 = 20))
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Physical Plan ==
*(1) Project [deptName#534]
+- *(1) Filter (isnotnull(deptId#533) && (deptId#533 = 20))
   +- *(1) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId), EqualTo(deptId,20)], ReadSchema: struct<deptId:int,deptName:string>
```

Das zweite Beispiel ist eine Bereichsauswahlabfrage für Datensätze vom Typ „Abteilung“. In SQL sieht diese Abfrage wie folgt aus:

```sql
SELECT deptName
FROM departments
WHERE deptId > 20
```

Ähnlich wie im ersten Beispiel zeigt die Ausgabe der folgenden Zelle die Abfrageergebnisse (Namen von zwei Abteilungen) und den Abfrageplan. Der Speicherort der Datendatei im FileScan-Operator zeigt, dass „deptIndex1“ zur Ausführung der Abfrage verwendet wurde.

:::zone pivot = "programming-language-scala"

```scala
// Filter with range selection predicate

val rangeFilter: DataFrame = deptDFrame.filter("deptId > 20").select("deptName")
rangeFilter.show()

rangeFilter.explain(true)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Filter with range selection predicate

rangeFilter = dept_DF.filter("""deptId > 20""").select("deptName")
rangeFilter.show()

rangeFilter.explain(True)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Filter with range selection predicate
DataFrame rangeFilter = deptDFrame.Filter("deptId > 20").Select("deptName");
rangeFilter.Show();

rangeFilter.Explain(true);

```

::: zone-end

Ergebnis:

```console
rangeFilter: org.apache.spark.sql.DataFrame = [deptName: string]
```

```console
|  DeptName|
|----------|
|Operations|
|     Sales|
```

```console
== Parsed Logical Plan ==
'Project [unresolvedalias('deptName, None)]
+- Filter (deptId#533 > 20)
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Analyzed Logical Plan ==
deptName: string
Project [deptName#534]
+- Filter (deptId#533 > 20)
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Optimized Logical Plan ==
Project [deptName#534]
+- Filter (isnotnull(deptId#533) && (deptId#533 > 20))
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Physical Plan ==
*(1) Project [deptName#534]
+- *(1) Filter (isnotnull(deptId#533) && (deptId#533 > 20))
   +- *(1) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId), GreaterThan(deptId,20)], ReadSchema: struct<deptId:int,deptName:string>
```

Das dritte Beispiel ist eine Abfrage, die Abteilungs- und Mitarbeiterdatensätze über die Abteilungs-ID verknüpft. Die entsprechende SQL-Anweisung ist unten dargestellt:

```sql
SELECT employees.deptId, empName, departments.deptId, deptName
FROM   employees, departments
WHERE  employees.deptId = departments.deptId
```

Die Ausgabe der Ausführung der folgenden Zelle zeigt die Abfrageergebnisse, d. h. die Namen von 14 Mitarbeitern und den Namen der Abteilung, in der die einzelnen Mitarbeiter arbeiten. Der Abfrageplan ist ebenfalls in der Ausgabe enthalten. Beachten Sie, wie die Dateispeicherorte für zwei FileScan-Operatoren zeigen, dass Spark die Indizes „empIndex“ und „deptIndex1“ verwendet hat, um die Abfrage auszuführen.

:::zone pivot = "programming-language-scala"

```scala
// Join

val eqJoin: DataFrame =
      empDFrame.
      join(deptDFrame, empDFrame("deptId") === deptDFrame("deptId")).
      select(empDFrame("empName"), deptDFrame("deptName"))

eqJoin.show()

eqJoin.explain(true)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

# Join

eqJoin = emp_DF.join(dept_DF, emp_DF.deptId == dept_DF.deptId).select(emp_DF.empName, dept_DF.deptName)

eqJoin.show()

eqJoin.explain(True)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

// Join
DataFrame eqJoin =
      empDFrame
      .Join(deptDFrame, empDFrame.Col("deptId") == deptDFrame.Col("deptId"))
      .Select(empDFrame.Col("empName"), deptDFrame.Col("deptName"));

eqJoin.Show();

eqJoin.Explain(true);

```

::: zone-end

Ergebnis:

```console
eqJoin: org.apache.spark.sql.DataFrame = [empName: string, deptName: string]
```

```console
|empName|  deptName|
|-------|----------|
|  SMITH|  Research|
|  JONES|  Research|
|   FORD|  Research|
|  ADAMS|  Research|
|  SCOTT|  Research|
|   KING|Accounting|
|  CLARK|Accounting|
| MILLER|Accounting|
|  JAMES|     Sales|
|  BLAKE|     Sales|
| MARTIN|     Sales|
|  ALLEN|     Sales|
|   WARD|     Sales|
| TURNER|     Sales|
```

```console
== Parsed Logical Plan ==
Project [empName#528, deptName#534]
+- Join Inner, (deptId#529 = deptId#533)
   :- Relation[empId#527,empName#528,deptId#529] parquet
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Analyzed Logical Plan ==
empName: string, deptName: string
Project [empName#528, deptName#534]
+- Join Inner, (deptId#529 = deptId#533)
   :- Relation[empId#527,empName#528,deptId#529] parquet
   +- Relation[deptId#533,deptName#534,location#535] parquet

== Optimized Logical Plan ==
Project [empName#528, deptName#534]
+- Join Inner, (deptId#529 = deptId#533)
   :- Project [empName#528, deptId#529]
   :  +- Filter isnotnull(deptId#529)
   :     +- Relation[empName#528,deptId#529] parquet
   +- Project [deptId#533, deptName#534]
      +- Filter isnotnull(deptId#533)
         +- Relation[deptId#533,deptName#534] parquet

== Physical Plan ==
*(3) Project [empName#528, deptName#534]
+- *(3) SortMergeJoin [deptId#529], [deptId#533], Inner
   :- *(1) Project [empName#528, deptId#529]
   :  +- *(1) Filter isnotnull(deptId#529)
   :     +- *(1) FileScan parquet [deptId#529,empName#528] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct<deptId:int,empName:string>, SelectedBucketsCount: 200 out of 200
   +- *(2) Project [deptId#533, deptName#534]
      +- *(2) Filter isnotnull(deptId#533)
         +- *(2) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct<deptId:int,deptName:string>, SelectedBucketsCount: 200 out of 200
```

## <a name="support-for-sql-semantics"></a>Unterstützung für SQL-Semantik

Die Indexverwendung ist hinsichtlich der Verwendung der Datenrahmen-API oder von Spark SQL transparent. Das folgende Beispiel zeigt dasselbe Join-Beispiel wie zuvor, in SQL-Form, wobei gegebenenfalls die Verwendung von Indizes gezeigt wird.

:::zone pivot = "programming-language-scala"

```scala
empDFrame.createOrReplaceTempView("EMP")
deptDFrame.createOrReplaceTempView("DEPT")

val joinQuery = spark.sql("SELECT EMP.empName, DEPT.deptName FROM EMP, DEPT WHERE EMP.deptId = DEPT.deptId")

joinQuery.show()
joinQuery.explain(true)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

from pyspark.sql import SparkSession

emp_DF.createOrReplaceTempView("EMP")
dept_DF.createOrReplaceTempView("DEPT")

joinQuery = spark.sql("SELECT EMP.empName, DEPT.deptName FROM EMP, DEPT WHERE EMP.deptId = DEPT.deptId")

joinQuery.show()
joinQuery.explain(True)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

empDFrame.CreateOrReplaceTempView("EMP");
deptDFrame.CreateOrReplaceTempView("DEPT");

var joinQuery = spark.Sql("SELECT EMP.empName, DEPT.deptName FROM EMP, DEPT WHERE EMP.deptId = DEPT.deptId");

joinQuery.Show();
joinQuery.Explain(true);

```

::: zone-end

Ergebnis:

```console

joinQuery: org.apache.spark.sql.DataFrame = [empName: string, deptName: string]
```

```console
|empName|  deptName|
|-------|----------|
|  SMITH|  Research|
|  JONES|  Research|
|   FORD|  Research|
|  ADAMS|  Research|
|  SCOTT|  Research|
|   KING|Accounting|
|  CLARK|Accounting|
| MILLER|Accounting|
|  JAMES|     Sales|
|  BLAKE|     Sales|
| MARTIN|     Sales|
|  ALLEN|     Sales|
|   WARD|     Sales|
| TURNER|     Sales|
```

```console
== Parsed Logical Plan ==
'Project ['EMP.empName, 'DEPT.deptName]
+- 'Filter ('EMP.deptId = 'DEPT.deptId)
   +- 'Join Inner
      :- 'UnresolvedRelation `EMP`
      +- 'UnresolvedRelation `DEPT`

== Analyzed Logical Plan ==
empName: string, deptName: string
Project [empName#528, deptName#534]
+- Filter (deptId#529 = deptId#533)
   +- Join Inner
      :- SubqueryAlias `emp`
      :  +- Relation[empId#527,empName#528,deptId#529] parquet
      +- SubqueryAlias `dept`
         +- Relation[deptId#533,deptName#534,location#535] parquet

== Optimized Logical Plan ==
Project [empName#528, deptName#534]
+- Join Inner, (deptId#529 = deptId#533)
   :- Project [empName#528, deptId#529]
   :  +- Filter isnotnull(deptId#529)
   :     +- Relation[empId#527,empName#528,deptId#529] parquet
   +- Project [deptId#533, deptName#534]
      +- Filter isnotnull(deptId#533)
         +- Relation[deptId#533,deptName#534,location#535] parquet

== Physical Plan ==
*(5) Project [empName#528, deptName#534]
+- *(5) SortMergeJoin [deptId#529], [deptId#533], Inner
   :- *(2) Sort [deptId#529 ASC NULLS FIRST], false, 0
   :  +- Exchange hashpartitioning(deptId#529, 200)
   :     +- *(1) Project [empName#528, deptId#529]
   :        +- *(1) Filter isnotnull(deptId#529)
   :           +- *(1) FileScan parquet [deptId#529,empName#528] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct<deptId:int,empName:string>
   +- *(4) Sort [deptId#533 ASC NULLS FIRST], false, 0
      +- Exchange hashpartitioning(deptId#533, 200)
         +- *(3) Project [deptId#533, deptName#534]
            +- *(3) Filter isnotnull(deptId#533)
               +- *(3) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/your-path/departments.parquet], PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct<deptId:int,deptName:string>
```

## <a name="explain-api"></a>API erläutern

Indizes sind hervorragend, aber woher wissen Sie, ob sie verwendet werden? Hyperspace ermöglicht es Benutzern, ihren ursprünglichen Plan mit dem aktualisierten indexabhängigen Plan zu vergleichen, bevor sie ihre Abfrage ausführen. Sie haben die Möglichkeit, zur Anzeige der Befehlsausgabe zwischen den Modi HTML/Klartext/Konsole zu wählen.

Die folgende Zelle zeigt ein Beispiel mit HTML. Der hervorgehobene Abschnitt stellt den Unterschied zwischen ursprünglichen und aktualisierten Plänen zusammen mit den verwendeten Indizes dar.

:::zone pivot = "programming-language-scala"

```scala
spark.conf.set("spark.hyperspace.explain.displayMode", "html")
hyperspace.explain(eqJoin) { displayHTML }
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

eqJoin = emp_DF.join(dept_DF, emp_DF.deptId == dept_DF.deptId).select(emp_DF.empName, dept_DF.deptName)

spark.conf.set("spark.hyperspace.explain.displayMode", "html")
hyperspace.explain(eqJoin, True, displayHTML)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

spark.Conf().Set("spark.hyperspace.explain.displayMode", "html");
spark.Conf().Set("spark.hyperspace.explain.displayMode.highlight.beginTag", "<b style=\"background:LightGreen\">");
spark.Conf().Set("spark.hyperspace.explain.displayMode.highlight.endTag", "</b>");

hyperspace.Explain(eqJoin, false, input => DisplayHTML(input));

```

::: zone-end

Ergebnis:

### <a name="plan-with-indexes"></a>Mit Indizes planen

```console
Project [empName#528, deptName#534]
+- SortMergeJoin [deptId#529], [deptId#533], Inner
   :- *(1) Project [empName#528, deptId#529]
   :  +- *(1) Filter isnotnull(deptId#529)
   :     +- *(1) FileScan parquet [deptId#529,empName#528] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct
   +- *(2) Project [deptId#533, deptName#534]
      +- *(2) Filter isnotnull(deptId#533)
         +- *(2) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct
```

### <a name="plan-without-indexes"></a>Ohne Indizes planen

```console
Project [empName#528, deptName#534]
+- SortMergeJoin [deptId#529], [deptId#533], Inner
   :- *(2) Sort [deptId#529 ASC NULLS FIRST], false, 0
   :  +- Exchange hashpartitioning(deptId#529, 200)
   :     +- *(1) Project [empName#528, deptId#529]
   :        +- *(1) Filter isnotnull(deptId#529)
   :           +- *(1) FileScan parquet [empName#528,deptId#529] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/your-path/employees.parquet], PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct
   +- *(4) Sort [deptId#533 ASC NULLS FIRST], false, 0
      +- Exchange hashpartitioning(deptId#533, 200)
         +- *(3) Project [deptId#533, deptName#534]
            +- *(3) Filter isnotnull(deptId#533)
               +- *(3) FileScan parquet [deptId#533,deptName#534] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/your-path/departments.parquet], PartitionFilters: [], PushedFilters: [IsNotNull(deptId)], ReadSchema: struct
```

### <a name="indexes-used"></a>Verwendete Indizes

```console
deptIndex1:abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/<container>/indexes/public/deptIndex1/v__=0
empIndex:abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/<container>/indexes/public/empIndex/v__=0
```

## <a name="refresh-indexes"></a>Indizes aktualisieren

Wenn sich die ursprünglichen Daten, für die ein Index erstellt wurde, ändern, erfasst der Index nicht mehr den neuesten Stand der Daten. Sie können einen solchen veralteten Index mithilfe des Befehls „refreshIndex“ aktualisieren. Dadurch wird der Index vollständig neu erstellt und gemäß den neuesten Datensätzen aktualisiert (keine Sorge, wir zeigen Ihnen, wie Sie Ihren Index in anderen Notebooks inkrementell aktualisieren können).

Die beiden folgenden Zellen zeigen ein Beispiel für dieses Szenario:

* Die erste Zelle fügt zwei weitere Abteilungen zu den ursprünglichen Abteilungsdaten hinzu. Sie liest die Liste der Abteilungen und gibt sie aus, um zu überprüfen, ob neue Abteilungen ordnungsgemäß hinzugefügt wurden. Die Ausgabe zeigt insgesamt sechs Abteilungen: vier alte und zwei neue. Der Aufruf von „refreshIndex“ aktualisiert „deptIndex1“, sodass der Index neue Abteilungen erfasst.
* In der zweiten Zelle wird unser Abfragebeispiel für die Bereichsauswahl ausgeführt. Die Ergebnisse sollten jetzt vier Abteilungen enthalten: zwei haben wir bereits bei der obigen Abfrage gesehen, und zwei sind die neuen Abteilungen, die wir gerade hinzugefügt haben.

### <a name="specific-index-refresh"></a>Spezifische Indexaktualisierung

:::zone pivot = "programming-language-scala"

```scala
val extraDepartments = Seq(
      (50, "Inovation", "Seattle"),
      (60, "Human Resources", "San Francisco"))

val extraDeptData: DataFrame = extraDepartments.toDF("deptId", "deptName", "location")
extraDeptData.write.mode("Append").parquet(deptLocation)

val deptDFrameUpdated: DataFrame = spark.read.parquet(deptLocation)

deptDFrameUpdated.show(10)

hyperspace.refreshIndex("deptIndex1")
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

extra_Departments = [(50, "Inovation", "Seattle"), (60, "Human Resources", "San Francisco")]

extra_departments_df = spark.createDataFrame(extra_Departments, dept_schema)
extra_departments_df.write.mode("Append").parquet(dept_Location)


dept_DFrame_Updated = spark.read.parquet(dept_Location)

dept_DFrame_Updated.show(10)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

var extraDepartments = new List<GenericRow>()
{
    new GenericRow(new object[] {50, "Inovation", "Seattle"}),
    new GenericRow(new object[] {60, "Human Resources", "San Francisco"})
};
    
DataFrame extraDeptData = spark.CreateDataFrame(extraDepartments, departmentSchema);
extraDeptData.Write().Mode("Append").Parquet(deptLocation);

DataFrame deptDFrameUpdated = spark.Read().Parquet(deptLocation);

deptDFrameUpdated.Show(10);

hyperspace.RefreshIndex("deptIndex1");

```

::: zone-end

Ergebnis:

```console
extraDepartments: Seq[(Int, String, String)] = List((50,Inovation,Seattle), (60,Human Resources,San Francisco))  
extraDeptData: org.apache.spark.sql.DataFrame = [deptId: int, deptName: string ... 1 more field]  
deptDFrameUpdated: org.apache.spark.sql.DataFrame = [deptId: int, deptName: string ... 1 more field]
```

&nbsp; &nbsp;

```console  
|deptId|       deptName|     location|
|------|---------------|-------------|
|    60|Human Resources|San Francisco|
|    10|     Accounting|     New York|
|    50|      Inovation|      Seattle|
|    40|     Operations|       Boston|
|    20|       Research|       Dallas|
|    30|          Sales|      Chicago|
```

### <a name="range-selection"></a>Bereichsauswahl

:::zone pivot = "programming-language-scala"

```scala
val newRangeFilter: DataFrame = deptDFrameUpdated.filter("deptId > 20").select("deptName")
newRangeFilter.show()

newRangeFilter.explain(true)
```

::: zone-end

:::zone pivot = "programming-language-python"

```python

newRangeFilter = dept_DFrame_Updated.filter("deptId > 20").select("deptName")
newRangeFilter.show()

newRangeFilter.explain(True)

```

::: zone-end

:::zone pivot = "programming-language-csharp"

```csharp

DataFrame newRangeFilter = deptDFrameUpdated.Filter("deptId > 20").Select("deptName");
newRangeFilter.Show();

newRangeFilter.Explain(true);

```

::: zone-end

Ergebnis:

```console
newRangeFilter: org.apache.spark.sql.DataFrame = [deptName: string]
```

```console
|       DeptName|
|---------------|
|Human Resources|
|      Inovation|
|     Operations|
|          Sales|
```

```console
== Parsed Logical Plan ==
'Project [unresolvedalias('deptName, None)]
+- Filter (deptId#674 > 20)
   +- Relation[deptId#674,deptName#675,location#676] parquet

== Analyzed Logical Plan ==
deptName: string
Project [deptName#675]
+- Filter (deptId#674 > 20)
   +- Relation[deptId#674,deptName#675,location#676] parquet

== Optimized Logical Plan ==
Project [deptName#675]
+- Filter (isnotnull(deptId#674) && (deptId#674 > 20))
   +- Relation[deptId#674,deptName#675,location#676] parquet

== Physical Plan ==
*(1) Project [deptName#675]
+- *(1) Filter (isnotnull(deptId#674) && (deptId#674 > 20))
   +- *(1) FileScan parquet [deptId#674,deptName#675] Batched: true, Format: Parquet, Location: InMemoryFileIndex[abfss://datasets@hyperspacebenchmark.dfs.core.windows.net/hyperspaceon..., PartitionFilters: [], PushedFilters: [IsNotNull(deptId), GreaterThan(deptId,20)], ReadSchema: struct<deptId:int,deptName:string>
```

## <a name="next-steps"></a>Nächste Schritte

* [Projekt: Hyperspace](https://microsoft.github.io/hyperspace/)
* [Azure Synapse Analytics](https://docs.microsoft.com/azure/synapse-analytics)